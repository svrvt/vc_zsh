# Эти имена не зависят от регистра и подчеркивания игнорируются. Для
# например, `allexport' эквивалентно `A__lleXP_ort'.

# Инициализация для нового стиля завершения.
if [[ $ZSH_VERSION > '4.2' ]]; then
	autoload -U compinit && compinit -d ${ZDOTDIR:-$HOME}/.zcompdump-$ZSH_VERSION ${${${ZSH_VERSION%%<4->*}:+-D}:--C}
else
	print "Система расширенного завершения не найдена; игнорирование настроек zstyle".
	function zstyle { }
fi

#--------------------------------------------------
# if [[ "$ZSH_VERSION" == 4.2.<0->* ]]; then
#-------------------------------------------------- 
if [[ "$ZSH_VERSION" == 5.<0->* ]]; then
	# Если вы теперь вставите url, он будет волшебным образом процитирован!
	# Но это работает только на 4.2.0 и более поздних версиях.
	autoload -Uz url-quote-magic
	zle -N selfinsert url-quote-magic
fi

# просмотр веб-страниц (подробности см. в разделе ``less ${^fpath}/pick-web-browser(N)'')
  автозагрузка pick-web-browser

# История поиска с подстановочными знаками? Нет проблем.
  autoload -U history-pattern-search
  zle -N history-pattern-search-backward history-pattern-search
  bindkey '^Z' history-pattern-search-backward

# Это попытается найти файлы с кодами слов и автоматически перекомпилировать их, если
# хотя бы один из исходных файлов новее, чем файл с кодом слова.
  autoload zrecompile

# Это множественное перемещение, основанное на сопоставлении шаблонов zsh (например, "mmv").
# Для получения дополнительной информации читайте ``less ${^fpath}/zmv(N)''.
  автозагрузка zmv

# Редактирование небольших файлов с помощью редактора командной строки.
  autoload -U zed

# Как xargs, но вместо чтения строк аргументов из стандартного ввода,
# он получает их из командной строки. Это возможно/полезно, потому что,
# особенно с рекурсивными операторами glob, zsh часто может построить командную
# строку для функции оболочки, которая длиннее, чем может быть принята внешней
# командой. Это то, что часто называют "дерьмовым лимитом выполнения в Linux" ;)
# Ограничение на количество символов или аргументов.
# $ =echo {1..30000}
# zsh: список аргументов слишком длинный: /bin/echo
# $ autoload -U zargs
# $ zargs -- =echo {1..30000}
# [ длинный список ;) ]
  autoload -U zargs

# Отредактируйте командную строку с помощью вашего обычного редактора.
# autoload -U edit-command-line
#
# ZFTP - это ftp-клиент, встроенный прямо в zsh. *Очень* аккуратно.
# if [[ $ZSH_VERSION > '4.3.4' ]]; then
	  autoload -U zfinit ; zfinit
	  ZLS_COLOURS='ma=7:di=0:ex=0:bd=0:cd=0:ln=0:so=0'
	  # Адрес электронной почты для анонимной сессии
	  # NOTE: _PLEASE_ change ``EMAIL_ADDR'' if u use my config!
	  (( ${+EMAIL_ADDR} )) || export EMAIL_ADDR="anonftp@strcat.de"
	  # Символ `G' для операции get и `P' для операции put.
	  ZFTP_TRANSFER=yes
	  # По умолчанию используется обратный прогрессбар, но он очень уродлив *narf*
	  # Возможные варианты: ``нет'', ``bar'' и ``percent''.
	  zstyle ':zftp:*' progress percent 
	  # Указывает минимальный интервал времени между обновлениями
	  # счетчиков прогресса в секундах.
	  zstyle ':zftp:*' update true
	  # Если установлено значение ``1'', ``да'' или ``истина'', генерация имен файлов
	  # (globbing) выполняется на удаленной машине вместо
	  # самого zsh. Черт возьми, нет!!!11!
	  zstyle ':zftp:*' remote-glob false
# fi

# Этот модуль должен загружаться автоматически, если вы используете выбор меню, но
# чтобы быть уверенным, мы сделаем это здесь
  zmodload -i zsh/complist

# Встроенный модуль, который может клонировать запущенную оболочку на другой терминал.
  zmodload -e zsh/clone

# Следить за логинами
watch=(notme)

# $ ls *.[!ch]
# zsh: событие не найдено: ch]
# $ unsetopt banghist
# $ ls *[!ch]
# 1.a 1.o 2.a 2.o
# ПРИМЕЧАНИЕ: Окружная форма используется для обратной совместимости и в качестве
# ярлыка в интерактивных оболочках, чтобы не набирать
# лишнюю обратную косую черту.
# $ ls *.[\!ch]
# работает, однако, и это, на самом деле, НЕ работает в сценарии оболочки,
# потому что механизм истории в интерактивном строковом редакторе - это то. 
# удаляет обратную косую черту.
unsetopt banghist

# При перечислении опций (с помощью `setopt', `unsetopt', `set -o' или `set +o'),
# те, которые включены по умолчанию, появляются в списке с префиксом `no'.
# Следовательно (если только не установлен KSH_OPTION_PRINT), `setopt' показывает все опции.
# чьи настройки изменены по сравнению с настройками по умолчанию.
#
# Сообщать о состоянии фоновых заданий немедленно, а не
# ждать, пока не будет напечатана подсказка.
setopt notify 

# Разрешить комментарии даже в интерактивных оболочках, например.
# $ uname # Эта команда выводит системную информацию.
# zsh: bad pattern: #
# $ setopt interactivecomments
# $ uname # Эта команда печатает системную информацию
# OpenBSD
setopt interactivecomments

# Посылать *не* сигнал HUP запущенным заданиям при выходе из оболочки.
setopt nohup

# Печатать возврат каретки непосредственно перед выводом приглашения в строке
# редакторе. Например:
# $ echo foo
# foo
# $ echo -n foo
# $ setopt nopromptcr
# $ echo -n foo
# foo$
setopt nopromptcr

# Если шаблон для генерации имени файла не имеет совпадений, удалите его
# шаблон из списка аргументов вместо того, чтобы сообщить об ошибке.
# Переопределяет NOMATCH.
setopt nullglob

# Perform =filename access
# $ setopt EQUALS
# $ echo =ls
# /bin/ls
# $ unsetopt EQUALS
# $ echo =ls 
# =ls
# ПРИМЕЧАНИЕ: Это не очень нужно, потому что zsh устанавливает это по умолчанию (начиная с версии 3.N)
setopt equals

# Звуковой сигнал при неоднозначном завершении.  Точнее говоря, это заставляет
# виджеты завершения возвращать статус 1 при неоднозначном завершении, что
# заставляет оболочку подавать звуковой сигнал, если опция BEEP также установлена; это может быть
# быть изменено, если завершение вызывается из пользовательского виджета.
setopt listbeep

# Попытайтесь сделать список завершения меньше (занимающим меньше строк) путем
# печатая совпадения в столбцах разной ширины.
setopt list_packed

# если скобки не имеют ни одной из вышеперечисленных форм, расширяет одиночные
# буквы и диапазоны букв, т. е:
# $ print 1{abw-z}2
# $ 1a2 1b2 1w2 1x2 1y2 1z2
setopt braceccl

# Сделайте встроенный модуль echo совместимым с командой BSD man page echo(1)
# команда.
# $ echo "foo\bar\baz"
# foaaz
# $ unsetopt bsdecho
# $ echo "foo\bar\baz"
# foo\bar\baz
unsetopt bsdecho

# Если аргумент команды cd (или подразумеваемый cd с установленной опцией
# опцией AUTO_CD) не является каталогом и не начинается с
# косой чертой, попробуйте расширить выражение, как если бы ему предшествовал
# '~' (см. раздел Расширение имени файла).
setopt cdablevars

# Сообщать о состоянии фоновых и приостановленных заданий перед выходом из оболочки
# с контролем заданий; вторая попытка выйти из оболочки будет успешной.
setopt checkjobs

# Заставить cd выталкивать старый каталог в стек каталогов. 
setopt autopushd 

# переход в каталог без "cd"
setopt autocd

# Меняет местами значения `+' и `-' при использовании с числом для 
# указания каталога в стеке.      
setopt pushdminus

# Если установлено, расширение параметров, замена команд и арифметическое 
# расширение параметров, замена команд и арифметическое расширение выполняются в подсказках.   
setopt pushdsilent

# Рассматривать символы '#', '~' и '^' как часть шаблонов 
# для генерации имен файлов и т. д. (Начальный символ '~' без кавычек
# всегда приводит к расширению именованного каталога).
# | $ grep word *~(*.gz|*.bz|*.bz2|*.zip|*.Z)
# ищет слово, отсутствующее в сжатых файлах
setopt extendedglob 

# Делаем запрос пользователю перед выполнением 'rm *' или 'rm path/*'
# $ rm -rf *
# zsh: вы уверены, что хотите удалить все файлы в /home/ru/foo [yn]?
setopt normstarsilent 

# При запросе пользователя перед выполнением `rm *' или `rm path/*',
# сначала подождите десять секунд и игнорируйте все, что было набрано за это время.
# Это позволяет избежать проблемы рефлекторного ответа `yes' на запрос.
# когда на самом деле этого не было. Ожидание и запрос всегда можно
# избежать, расширив `*' в ZLE (с помощью табуляции).
setopt no_rm_star_wait

# Заткнитесь ;)
setopt nobeep 

# Подавать звуковой сигнал при попытке доступа к записи истории, которой
# не существует.
setopt histbeep

# При записи файла истории старые команды, которые дублируют более новые
# опускаются.
setopt HISTSAVENODUPS

# При поиске записей истории в строковом редакторе не отображать
# дубликаты ранее найденных строк, даже если дубликаты не являются
# смежными.                       
setopt HISTFINDNODUPS

# Если внутренняя история должна быть обрезана, чтобы добавить текущую командную строку,
# установка этой опции приведет к тому, что самое старое событие истории, содержащее дубликат.
# будет потеряно до потери уникального события из списка.
# Вы должны быть уверены, что значение HISTSIZE больше.
# чем SAVEHIST, чтобы оставить место для дублированных
# событий, иначе эта опция будет вести себя так же, как HIST_IGNORE_ALL_DUPS
# когда история заполнится уникальными событиями.
setopt hist_expire_dups_first

# Если новая командная строка, добавляемая в список истории, дублирует
# более старую, старая команда удаляется из списка (даже если она
# не является предыдущим событием).
setopt hist_ignore_all_dups

# Не вносить командные строки в список истории.
# если они являются дубликатами предыдущего события.
setopt hist_ignore_dups

# Удалять командные строки из списка истории, если первый символ в
# строке является пробел, или если один из расширенных псевдонимов содержит
# ведущий пробел.
# Обратите внимание, что команда остается во внутренней истории до тех пор, пока не будет введена следующая
# команды, после чего она исчезает, позволяя вам ненадолго повторно использовать
# или отредактировать строку.  Если вы хотите, чтобы она исчезла сразу, без
# ввода другой команды, наберите пробел и нажмите return.
unsetopt hist_ignore_space

# HIST_REDUCE_BLANKS
# Удаляет лишние пробелы из каждой командной строки.
# добавляемых в список истории.
setopt hist_reduce_blanks

# Каждый раз, когда пользователь вводит строку с расширением истории,
# не выполняйте строку напрямую; вместо этого выполните
# расширение истории и перезагрузить строку в буфер редактирования.
setopt hist_verify

# Удаление определений функций из списка истории.
# Обратите внимание, что функция остается во внутренней истории до тех пор, пока не будет введена следующая
# команды, после чего она исчезает, позволяя вам ненадолго повторно использовать
# или отредактировать определение.
unsetopt hist_no_functions

# Удаляет команду history (fc -l) из списка history
# при вызове.
# Обратите внимание, что команда остается во внутренней истории до тех пор, пока не будет введена следующая
# команды, после чего она исчезает, позволяя вам ненадолго повторно использовать
# или отредактировать строку.
setopt hist_no_store

# Если это значение установлено, сессии zsh будут добавлять свой список истории в
# файлу истории, а не перезаписывать его. Таким образом, несколько параллельных
# сеансов zsh все их списки истории будут добавлены в
# файл истории в порядке их завершения.
setopt appendhistory

# Если значение не установлено, курсор будет установлен в конец слова, если завершение
# начато. В противном случае он остается на месте, и завершение выполняется с обоих концов.
setopt completeinword 

# При перечислении файлов, являющихся возможными завершениями, показывать
# тип каждого файла с последующей идентификационной меткой.
setopt list_types

# Не требуйте лидирующего '.' в имени файла для явного сопоставления.
setopt globdots


# Пытаться исправить написание всех аргументов в строке.
setopt correctall

# По умолчанию выводит список заданий в длинном формате.
setopt longlistjobs 

# Печатать восьмибитные символы буквально в списках завершения и т. д.
# Эта опция не нужна, если ваша система правильно определяет
# возможность печати восьмибитных символов (см. man-страницу ctype(3)).
setopt printeightbit

# Не помещайте несколько копий одного и того же каталога в
# стек
setopt pushdignoredups

# Эта опция как импортирует новые команды из файла истории, так и
# приводит к тому, что набранные вами команды добавляются в файл истории (последнее
# последняя опция подобна указанию INC_APPEND_HISTORY).
# Строки истории также выводятся с временными метками, например
# EXTENDED_HISTORY (что облегчает поиск места, где
# мы прервали чтение файла после его перезаписи).
setopt sharehistory 

# Попытайтесь исправить написание всех аргументов в строке.
# No... not really... it's make me crazy *g*
# setopt correctall

# Сохраняем временную метку начала каждой команды (в секундах от эпохи)
# и продолжительность (в секундах) в файл истории.  Формат
# этих данных с префиксом следующий:
# ':<время начала>:<прошедшие секунды>;<команда>'.
# i. e:
# : 1054961691:0;/usr/games/fortune -f
unsetopt extendedhistory

# Разрешить короткие формы конструкций for, select, if и функций, т.
# e.: ``for i (*.o) rm $i'' вместо ``for i in *.o; do rm $i; done''
setopt shortloops

# Не запускать *не* все фоновые задания с более низким приоритетом
unsetopt bgnice 

# Если эта опция не установлена, выводите управление потоком через символы start/stop
# (обычно назначаемых ^S/^Q) в редакторе оболочки отключен.
unsetopt flow_control

# Разрешить последовательность символов `''' для обозначения одиночной кавычки внутри
# строк с одиночными кавычками.   Обратите внимание, что это не относится к строкам с кавычками
# Разрешите 'Henry''s Garage' вместо 'Henry'\''s Garage'.
# с использованием формата $'...', где может использоваться обратная скрещенная одиночная кавычка.
setopt RC_QUOTES

